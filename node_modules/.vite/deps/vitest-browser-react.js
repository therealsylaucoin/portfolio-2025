import {
  require_client
} from "./chunk-EYC5U7RM.js";
import "./chunk-KDCVS43I.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/vitest-browser-react/dist/chunk-A67NRMUW.js
var import_react = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);
import { debug, getElementLocatorSelectors } from "@vitest/browser/utils";
function act(cb) {
  const _act = import_react.default.act || import_react.default.unstable_act;
  if (typeof _act !== "function") {
    cb();
  } else {
    globalThis.IS_REACT_ACT_ENVIRONMENT = true;
    _act(cb);
    globalThis.IS_REACT_ACT_ENVIRONMENT = false;
  }
}
var mountedContainers = /* @__PURE__ */ new Set();
var mountedRootEntries = [];
function render(ui, { container, baseElement, wrapper: WrapperComponent } = {}) {
  if (!baseElement) {
    baseElement = document.body;
  }
  if (!container) {
    container = baseElement.appendChild(document.createElement("div"));
  }
  let root;
  if (!mountedContainers.has(container)) {
    root = createConcurrentRoot(container);
    mountedRootEntries.push({ container, root });
    mountedContainers.add(container);
  } else {
    mountedRootEntries.forEach((rootEntry) => {
      if (rootEntry.container === container) {
        root = rootEntry.root;
      }
    });
  }
  act(() => {
    root.render(
      strictModeIfNeeded(wrapUiIfNeeded(ui, WrapperComponent))
    );
  });
  return {
    container,
    baseElement,
    debug: (el, maxLength, options) => debug(el, maxLength, options),
    unmount: () => {
      act(() => {
        root.unmount();
      });
    },
    rerender: (newUi) => {
      act(() => {
        root.render(
          strictModeIfNeeded(wrapUiIfNeeded(newUi, WrapperComponent))
        );
      });
    },
    asFragment: () => {
      return document.createRange().createContextualFragment(container.innerHTML);
    },
    ...getElementLocatorSelectors(baseElement)
  };
}
function cleanup() {
  mountedRootEntries.forEach(({ root, container }) => {
    act(() => {
      root.unmount();
    });
    if (container.parentNode === document.body) {
      document.body.removeChild(container);
    }
  });
  mountedRootEntries.length = 0;
  mountedContainers.clear();
}
function createConcurrentRoot(container) {
  const root = import_client.default.createRoot(container);
  return {
    render(element) {
      root.render(element);
    },
    unmount() {
      root.unmount();
    }
  };
}
var config = {
  reactStrictMode: false
};
function strictModeIfNeeded(innerElement) {
  return config.reactStrictMode ? import_react.default.createElement(import_react.default.StrictMode, null, innerElement) : innerElement;
}
function wrapUiIfNeeded(innerElement, wrapperComponent) {
  return wrapperComponent ? import_react.default.createElement(wrapperComponent, null, innerElement) : innerElement;
}

// node_modules/vitest-browser-react/dist/index.js
import { page } from "@vitest/browser/context";
import { beforeEach } from "vitest";
page.extend({
  render,
  [Symbol.for("vitest:component-cleanup")]: cleanup
});
beforeEach(() => {
  cleanup();
});
export {
  cleanup,
  render
};
//# sourceMappingURL=vitest-browser-react.js.map
